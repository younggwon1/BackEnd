# [Spring] DI/IoC

> 객체 지향 프로그래밍에서 클래스 변경은 다른 클래스에 영향을 끼치지 않으면서 변경이 가능해야 한다. 
>
> 따라서 이러한 변경이 가능하게 할 수 있도록 도입된 기능이 바로 **DI(Dependency Injection)**와 **IoC(Inversion of Control)**이다.



<img width="570" alt="스크린샷 2022-03-31 오후 2 31 45" src="https://user-images.githubusercontent.com/73063032/160983317-190794d3-0daf-4c28-86fe-93c07cf3c7d7.png" style="zoom:67%;" >



### DI(Dependency Injection, 의존성 주입)

`DI(Dependency Injection)`란 **스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능**으로, **객체를 직접 생성하는 게 아니라 외부에서 생성한 후 주입 시켜주는 방식**이다. **DI(의존성 주입)를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.**

여기서 특정 클래스가 제 기능을 다하기 위해, 다른 클래스의 생성을 필요로하는 경우 클래스 간에 **`의존성`** 이 존재한다고 표현한다.



<img width="725" alt="스크린샷 2022-04-08 오전 11 24 55" src="https://user-images.githubusercontent.com/73063032/162350913-024c1d54-6ee3-4407-bc7c-ff96e9c60d5e.png" style="zoom:67%;" >

첫번째 방법은 A객체가 B와 C객체를 New 생성자를 통해서 직접 생성하는 방법이고, 두번째 방법은 **외부에서 생성 된 객체를 setter()를 통해 사용하는 방법**이다. 이러한 두번째 방식이 의존성 주입의 예시인데, `A 객체`에서 **`B, C객체`를 사용(의존)할 때** `A 객체`에서 **직접 생성 하는 것이 아니라** **`외부(IOC컨테이너)`에서 생성된 `B, C객체`를 조립(주입)시켜 `setter` 혹은 `생성자`를 통해 사용하는 방식**이다.

<img width="712" alt="스크린샷 2022-04-08 오전 11 27 22" src="https://user-images.githubusercontent.com/73063032/162351147-1da35ab7-d92e-498e-a25d-a4df3ee5d0c2.png" style="zoom:50%;" >

**스프링에서는 객체를 `Bean`**이라고 부르며, 프로젝트가 실행될때 사용자가 Bean으로 관리하는 객체들의 생성과 소멸에 관련된 작업을 자동적으로 수행해주는데 객체가 생성되는 곳을 스프링에서는 Bean 컨테이너라고 부른다.



아래의 코드를 통해 의존성에 대해 살펴보도록 하자

```java
class Animal{
    Human human;
    
    public Animal(){
        this.human = new Human();
    }
}
```

보통 의존 관계는 **`new`** 키워드를 선언하는 것과 밀접한 관련이 있다. 위의 코드에서 Animal 클래스는 Human 클래스를 필요로 하며, 따라서 Animal 클래스는 Human 클래스에 의존성을 가진다고 할 수 있다.

하지만 객체를 생성할 때 직접 클래스에 new 연산자를 이용하여 생성하게 되면, 각 클래스들간 결합도가 높아지게 되고 나중에 프로젝트가 복잡해질시 유지보수가 힘들어지게 된다. 따라서, 결합도를 낮출수록(=의존성 혹은 종속성을 줄일수록) 코드의 재활용성 및 유연한 코드 작성이 가능해진다.



DI는 개발자가 직접 코딩을 하여 객체를 생성하는 것이 아니라, 컨테이너가 생성시켜 준다. 이렇게 된다면 코드에서 직접적인 연관 관계가 발생하지 않아 각 클래스들의 변경이 자유로워진다. 이를 느슨한 결합이라고 한다.

따라서 각 클래스들간 연관 관계를 클래스 자체 내에서 맺어주는 것이 아니라 스프링 자체에서 설정을 통해 연관 관계를 맺어줌으로써 결합도를 낮춘다.



**DI 장점**

- 클래스들 간 의존 관계를 최소화 할 수 있다.
- 프로젝트 유지보수가 용이하다.
- 기존에는 개발자가 직접 객체의 생성과 소멸을 제어했는데 DI로 인해 객체의 생성과 소멸 등 클래스간 의존 관계를 스프링 컨테이너가 제어해준다.









### IoC(Inversion of Conrol, **제어의 역전**)

스프링 프레임워크에서는 주입 대상이 되는 의존성 객체를 Bean이라고 한다. 처음 프로젝트가 실행될 때 Bean을 생성하여 Bean 컨테이너에서 관리하게 되고, 이후 필요시 컨테이너로부터 Bean을 주입받아 활용하는 것이다.

이러한 방식은 Bean 객체의 생성 및 소멸을 개발자가 아닌 프레임워크가 주도하게 함으로써, Singleton Pattern의 특징에서 알 수 있듯 빈번한 객체의 생성 및 소멸로 인한 자원 낭비를 줄이고 재사용성을 높인다는 이점이 있다.

이렇게 메소드나 객체의 호출을 개발자가 결정하지 않고, 프레임워크가 결정하는 것을 **`제어의 역전(Inversion of Control)`** 이라고 표현한다. 스프링에서의 Bean이 만들어지고 실행되는 과정은 아래와 같다.



`IoC(Inversion of Control)`란 "제어의 역전" 이라는 의미로, 말 그대로 **메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것을 의미**한다.

`IoC`는 **제어의 역전이라고 말하며, 간단히 말해 "제어의 흐름을 바꾼다"**라고 한다.

객체의 **의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성**할 수 있게 하여 **가독성 및 코드 중복, 유지 보수를 편하게** 할 수 있게 한다.



1. 최초 객체가 생성된다.
2. 의존성 객체가 주입된다.
   - 필드 인스턴스나 setter 혹은 생성자 등을 통해 주입
   - `@Autowired` 선언하여 프레임워크가 컨테이너에서, 선언된 객체 타입과 일치하는 Bean을 찾아 주입함
3. 의존성 객체 메소드가 호출된다.



여기서 의존성 객체를 주입할 때 스프링에서 권장하는 방식은 **생성자 방식** 이다. 다양한 이유가 있겠지만, 공식문서에 의하면 주된 이유로 **순환참조로 인한 에러를 사전에 방지** 할 수 있다는 점을 언급하고 있다.













**참고**

[][Spring] [스프링 DI, IoC 이해하기](https://kingofbackend.tistory.com/41)

[Spring DI와 IoC](https://junu0516.github.io/posts/스프링에서의_di와_ioc/)



